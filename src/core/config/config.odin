package config

import "core:os"
import "core:fmt"
import "core:strings"
import "../../utils/errors"
import "../../utils/logging"


ostConfigHeader:= "#This file was generated by the Ostrich Database Engine\n#Do NOT modify this file unless you know what you are doing\n#For more information on the Ostrich Database Engine visit: https://github.com/SchoolyB/Ostrich\n\n\n\n"

configOne:= "OST_ENGINE_INIT" //values: true, false...has the engine been initialized
configTwo:= "OST_ENGINE_LOGGING" //values: simple, verbose, none??? 
configThree:= "OST_ENGINE_HELP" //values: true, false...helpful hints for users


main ::proc()
{
	if (OST_CHECK_IF_CONFIG_FILE_EXISTS() == false )
	{
		OST_CREATE_CONFIG_FILE()
	}
}


OST_CHECK_IF_CONFIG_FILE_EXISTS ::proc() -> bool
{
	configExists:bool
  configPath,e := os.open("../bin")
  defer os.close(configPath)
	
  foundFiles, err := os.read_dir(configPath, -1)
  for file in foundFiles {
		if file.name == "ostrich.config"
		{
			configExists = true
		}
  }
	return configExists
}

//the config file will contain info like: has the initial user setup been done, engine settings, etc
OST_CREATE_CONFIG_FILE :: proc() -> bool
{
	configPath:= "../bin/ostrich.config"
	file,e:= os.open(configPath, os.O_CREATE, 0o666)
	os.close(file)
	if  e != 0
	{
			errors.throw_utilty_error(1, "Error creating config file", "OST_GENERATE_CONFIG")
			logging.log_utils_error("Error creating config file", "OST_GENERATE_CONFIG")
			return false
		}
		msg:= transmute([]u8)ostConfigHeader
		os.open(configPath, os.O_APPEND | os.O_WRONLY, 0o666)
		defer os.close(file)
		writter,ok:= os.write(file,msg)
		if ok != 0
		{
			errors.throw_utilty_error(1, "Error writing to config file", "OST_GENERATE_CONFIG")
			logging.log_utils_error("Error writing to config file", "OST_GENERATE_CONFIG")
			return false
		}

		if !OST_FIND_ALL_CONFIGS(configOne, configTwo, configThree)
		{
			errors.throw_utilty_error(1, "Error writing to config file", "OST_GENERATE_CONFIG")
			logging.log_utils_error("Error writing to config file", "OST_GENERATE_CONFIG")
			
			OST_APPEND_AND_SET_CONFIG(configOne, "false")
			OST_APPEND_AND_SET_CONFIG(configTwo, "simple")
			OST_APPEND_AND_SET_CONFIG(configThree, "true")	
		}
	return true
}

// Searches the config file for a specific config name that is passed in as a string
// Returns true if found, false if not found
OST_FIND_CONFIG :: proc(c: string) -> bool {
    data, err := os.read_entire_file("../bin/ostrich.config")
    if err != false {
        return false
    }
    defer delete(data)
    
    content := string(data)
    lines := strings.split(content, "\n")
    defer delete(lines)
    
    for line in lines {
        if strings.contains(line, c) {
            return true
        }
    }
    return false
}

// Ensures that all config names are found in the config file
OST_FIND_ALL_CONFIGS :: proc(configs: ..string) -> bool {
    for config in configs {
        if !OST_FIND_CONFIG(config) {
            return false
        }
    }
    return true
}


OST_APPEND_AND_SET_CONFIG::proc(c:string, value:string) -> int
{
	file,e:=os.open("../bin/ostrich.config", os.O_APPEND | os.O_WRONLY, 0o666)
	defer os.close(file)
	concat:=strings.concatenate([]string{c," : ", value, "\n"})
	str:= transmute([]u8)concat
		writter,ee:= os.write(file, str)
	return 0
}



OST_READ_CONFIG_VALUE :: proc(config: string) -> string {
    data, err := os.read_entire_file("../bin/ostrich.config")
    
    defer delete(data)

    content := string(data)
    lines := strings.split(content, "\n")
    defer delete(lines)

    for line in lines {
        if strings.contains(line, config) {
            parts := strings.split(line, " : ")
            if len(parts) >= 2 {
                return strings.trim_space(parts[1])
            }
            break  // Found the config, but it's malformed
        }
    }

    return ""  // Config not found
}



OST_TOGGLE_CONFIG :: proc(config: string) -> bool {
    updated := false
		foo:bool
    data, err := os.read_entire_file("../bin/ostrich.config")

    defer delete(data)

    content := string(data)
    lines := strings.split(content, "\n")
    defer delete(lines)

    new_lines := make([dynamic]string, 0, len(lines))
    defer delete(new_lines)

    for line in lines {
        new_line := line
        if strings.contains(line, config) {
            if strings.contains(line, "true") {
                new_line,foo = strings.replace(line, "true", "false", 1)
                updated = true
            } else if strings.contains(line, "false") {
                new_line,foo = strings.replace(line, "false", "true", 1)
                updated = true
            }
        }
        append(&new_lines, new_line)
    }

    if updated {
        new_content := strings.join(new_lines[:], "\n")
        os.write_entire_file("../bin/ostrich.config", transmute([]byte)new_content)
    }

    return updated
	}