package config

import "core:os"
import "core:fmt"
import "core:strings"
import "../../utils/errors"
import "../../utils/logging"


ostConfigHeader:= "#This file was generated by the Ostrich Database Engine\n#Do NOT modify this file unless you know what you are doing\n#For more information on the Ostrich Database Engine visit: https://github.com/SchoolyB/Ostrich\n\n\n\n"

configOne:= "OST_ENGINE_INIT" //values: true, false...has the engine been initialized
configTwo:= "OST_ENGINE_LOGGING" //values: simple, verbose, none??? 
configThree:= "OST_ENGINE_HELP" //values: true, false...helpful hints for users


main ::proc()
{
	if (OST_CHECK_IF_CONFIG_FILE_EXISTS() == false )
	{
		OST_CREATE_CONFIG_FILE()
	}
}


OST_CHECK_IF_CONFIG_FILE_EXISTS ::proc() -> bool
{
	configExists:bool
  configPath,e := os.open("../bin")
  defer os.close(configPath)
	
  foundFiles, err := os.read_dir(configPath, -1)
  for file in foundFiles {
		if file.name == "ostrich.config"
		{
			configExists = true
		}
  }
	return configExists
}

//the config file will contain info like: has the initial user setup been done, engine settings, etc
OST_CREATE_CONFIG_FILE :: proc() -> bool
{
	configPath:= "../bin/ostrich.config"
	file,e:= os.open(configPath, os.O_CREATE, 0o666)
	os.close(file)
	if  e != 0
	{
			errors.throw_utilty_error(1, "Error creating config file", "OST_GENERATE_CONFIG")
			logging.log_utils_error("Error creating config file", "OST_GENERATE_CONFIG")
			return false
		}
		msg:= transmute([]u8)ostConfigHeader
		os.open(configPath, os.O_APPEND | os.O_WRONLY, 0o666)
		defer os.close(file)
		writter,ok:= os.write(file,msg)
		if ok != 0
		{
			errors.throw_utilty_error(1, "Error writing to config file", "OST_GENERATE_CONFIG")
			logging.log_utils_error("Error writing to config file", "OST_GENERATE_CONFIG")
			return false
		}

		if !OST_FIND_ALL_CONFIGS(configOne, configTwo, configThree)
		{
			errors.throw_utilty_error(1, "Error writing to config file", "OST_GENERATE_CONFIG")
			logging.log_utils_error("Error writing to config file", "OST_GENERATE_CONFIG")
			
			OST_APPEND_AND_SET_CONFIG(configOne, "false")
			OST_APPEND_AND_SET_CONFIG(configTwo, "simple")
			OST_APPEND_AND_SET_CONFIG(configThree, "true")	
		}
	return true
}

// Searches the config file for a specific config name that is passed in as a string
// Returns true if found, false if not found
OST_FIND_CONFIG :: proc(c: string) -> bool {
    data, err := os.read_entire_file("../bin/ostrich.config")
    if err != false {
        return false
    }
    defer delete(data)
    
    content := string(data)
    lines := strings.split(content, "\n")
    defer delete(lines)
    
    for line in lines {
        if strings.contains(line, c) {
            return true
        }
    }
    return false
}

// Ensures that all config names are found in the config file
OST_FIND_ALL_CONFIGS :: proc(configs: ..string) -> bool {
    for config in configs {
        if !OST_FIND_CONFIG(config) {
            return false
        }
    }
    return true
}


OST_APPEND_AND_SET_CONFIG::proc(c:string, value:string) -> int
{
	file,e:=os.open("../bin/ostrich.config", os.O_APPEND | os.O_WRONLY, 0o666)
	defer os.close(file)
	concat:=strings.concatenate([]string{c," : ", value, "\n"})
	str:= transmute([]u8)concat
		writter,ee:= os.write(file, str)
	return 0
}


OST_CHECK_CONFIG_VALUE::proc(c:string, value:string) -> bool
{
		data, err := os.read_entire_file("../bin/ostrich.config")
		if err != false {
				return false
		}
		defer delete(data)
		
		content := string(data)
		lines := strings.split(content, "\n")
		defer delete(lines)
		
		for line in lines {
				if strings.contains(line, c) {
						if strings.contains(line, value) {
								return true
						}
				}
		}
		return false
}

